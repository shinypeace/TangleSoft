<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>–ú–∞—Å—Ç–µ—Ä –£–∑–ª–æ–≤</title>
    
    <!-- VK Bridge -->
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@600;800;900&display=swap');

        :root {
            /* Light Theme (Default) */
            --bg-color: #ebf2f7;
            --app-bg: #ebf2f7;
            --primary: #6c5ce7;
            --primary-dark: #5849be;
            --text: #2d3436;
            --text-light: #636e72;
            --shadow-light: -4px -4px 12px #ffffff;
            --shadow-dark: 4px 4px 12px #d1d9e6;
            --radius-btn: 16px;
            --card-bg: #ebf2f7;
            
            /* Overlay Colors Light */
            --overlay-bg: rgba(255, 255, 255, 0.95);
        }

        body.dark {
            /* Dark Theme */
            --bg-color: #1e272e;
            --app-bg: #1e272e;
            --primary: #a29bfe;
            --primary-dark: #6c5ce7;
            --text: #dfe6e9;
            --text-light: #b2bec3;
            --shadow-light: -4px -4px 10px rgba(255, 255, 255, 0.05);
            --shadow-dark: 4px 4px 10px rgba(0, 0, 0, 0.3);
            --card-bg: #1e272e;
            
            /* Overlay Colors Dark */
            --overlay-bg: rgba(30, 39, 46, 0.95);
        }

        * {
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        body {
            margin: 0;
            height: 100vh;
            width: 100vw;
            background-color: #2d3436; /* Outer bg always dark */
            font-family: 'Nunito', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
            transition: background-color 0.3s;
        }

        /* FRAME */
        #app-frame {
            position: relative;
            width: 100%;
            max-width: 380px;
            height: 100%;
            max-height: 850px;
            background: var(--app-bg);
            box-shadow: 0 30px 60px rgba(0,0,0,0.3);
            overflow: hidden;
            display: flex;
            flex-direction: column;
            transition: background 0.3s;
        }

        @media (min-width: 450px) {
            #app-frame {
                height: 90vh;
                border-radius: 32px;
                border: 6px solid #353b48;
            }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        /* UI ARCHITECTURE */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: var(--app-bg);
            z-index: 10;
            transition: opacity 0.3s ease, transform 0.3s ease, background 0.3s;
            padding: 20px;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.96);
        }
        
        .screen.overlay {
            background: var(--overlay-bg);
            backdrop-filter: blur(5px);
        }

        .pointer-auto { pointer-events: auto; }

        /* TYPOGRAPHY */
        h1 {
            font-size: 2.5rem;
            color: var(--text);
            margin: 0 0 5px 0;
            line-height: 1;
            text-align: center;
            transition: color 0.3s;
        }
        h1 span { color: var(--primary); }
        
        .subtitle {
            color: var(--text-light);
            font-size: 0.95rem;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 600;
            transition: color 0.3s;
        }

        /* COMPONENTS */
        .neu-btn {
            background: var(--card-bg);
            border: none;
            border-radius: var(--radius-btn);
            padding: 14px;
            box-shadow: var(--shadow-dark), var(--shadow-light);
            color: var(--text);
            font-weight: 800;
            font-family: 'Nunito', sans-serif;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            position: relative;
        }

        .neu-btn:active {
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.2), inset -2px -2px 5px rgba(255,255,255,0.1);
            transform: translateY(1px);
            color: var(--primary);
        }
        
        .neu-btn.primary {
            background: var(--primary);
            color: #fff;
            box-shadow: 0 4px 15px rgba(108, 92, 231, 0.4);
        }
        body.dark .neu-btn.primary { color: #1e272e; }
        
        .neu-btn.primary:active {
            background: var(--primary-dark);
            box-shadow: inset 0 2px 5px rgba(0,0,0,0.2);
            transform: scale(0.98);
        }

        .neu-btn.icon-only {
            width: 44px;
            height: 44px;
            padding: 0;
            border-radius: 50%;
        }
        .neu-btn svg { width: 22px; height: 22px; fill: currentColor; }

        /* Main Menu */
        #menuScreen {
            justify-content: center;
            align-items: center;
        }
        .menu-controls {
            display: flex;
            gap: 20px;
            margin-top: 25px;
        }

        /* Level Select */
        #levelScreen { padding-top: 70px; }
        .top-bar {
            position: absolute;
            top: 0; left: 0; right: 0;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            z-index: 2;
        }
        .scroll-container {
            flex: 1;
            overflow-y: auto;
            width: 100%;
            padding: 5px 4px;
            -webkit-overflow-scrolling: touch;
        }
        .scroll-container::-webkit-scrollbar { display: none; }

        .level-card {
            background: var(--card-bg);
            border-radius: 16px;
            padding: 14px 18px;
            margin-bottom: 12px;
            box-shadow: var(--shadow-dark), var(--shadow-light);
            cursor: pointer;
            transition: transform 0.2s, background 0.3s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .level-card:active { transform: scale(0.98); }
        .level-card.locked { opacity: 0.5; filter: grayscale(0.8); }
        
        .lvl-info h3 { margin: 0; font-size: 1rem; color: var(--text); }
        .lvl-info p { margin: 2px 0 0; font-size: 0.8rem; color: var(--text-light); }
        
        .status-badge {
            font-size: 0.75rem;
            font-weight: 800;
            padding: 4px 10px;
            border-radius: 10px;
            background: #dfe6e9;
            color: #636e72;
            min-width: 80px;
            text-align: center;
        }
        .status-badge.open { background: rgba(0, 184, 148, 0.15); color: #00b894; }
        body.dark .status-badge { background: #353b48; color: #b2bec3; }
        body.dark .status-badge.open { background: rgba(0, 184, 148, 0.2); color: #55efc4; }

        /* Other Games Screen */
        #otherGamesScreen { padding-top: 70px; }
        .games-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            padding: 10px 4px;
            overflow-y: auto;
            margin: auto 0; /* Vertical Center Logic */
            max-height: 100%;
        }
        .game-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        .game-icon {
            width: 70px;
            height: 70px;
            border-radius: 18px;
            background: #fff;
            box-shadow: var(--shadow-dark), var(--shadow-light);
            overflow: hidden;
            margin-bottom: 8px;
            transition: transform 0.2s;
        }
        .game-item:active .game-icon { transform: scale(0.95); }
        .game-icon img { width: 100%; height: 100%; object-fit: cover; }
        .game-name {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text);
            text-align: center;
            line-height: 1.2;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0; left: 0; width: 100%;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 5;
        }
        #hud button { pointer-events: auto; }
        .level-pill {
            background: var(--card-bg);
            padding: 6px 14px;
            border-radius: 20px;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.1), inset -2px -2px 5px rgba(255,255,255,0.1);
            font-weight: 800;
            color: var(--primary);
            font-size: 0.9rem;
        }

        /* Settings Modal */
        #settingsModal {
            justify-content: center;
            align-items: center;
            background: rgba(0,0,0,0.6);
            backdrop-filter: blur(10px);
        }
        .modal-card {
            background: var(--app-bg);
            padding: 30px;
            border-radius: 24px;
            width: 90%;
            max-width: 320px;
            display: flex;
            flex-direction: column;
            align-items: center;
            box-shadow: 0 10px 30px rgba(0,0,0,0.3);
        }
        
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            margin-bottom: 20px;
            font-weight: 700;
            color: var(--text);
        }
        .toggle-switch {
            width: 50px;
            height: 28px;
            background: #b2bec3;
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            transition: background 0.3s;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px; left: 3px;
            width: 22px; height: 22px;
            background: white;
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            transition: transform 0.3s;
        }
        .toggle-switch.active { background: var(--primary); }
        .toggle-switch.active::after { transform: translateX(22px); }

        /* Tutorial Canvas */
        #tutorialCanvas {
            width: 200px;
            height: 200px;
            background: transparent;
            margin-bottom: 20px;
        }
        
        /* Unlock Modal Special */
        .unlock-icon {
            font-size: 4rem;
            margin-bottom: 10px;
            animation: bounce 1s infinite;
        }
        @keyframes bounce {
            0%, 100% { transform: translateY(0); }
            50% { transform: translateY(-10px); }
        }

    </style>
</head>
<body>

<!-- MUSIC ELEMENT -->
<audio id="bgMusic" src="music.mp3" loop></audio>

<div id="app-frame">
    
    <!-- GAME CANVAS -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" class="hidden">
        <button id="btnPause" class="neu-btn icon-only">
            <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
        </button>
        <div class="level-pill" id="hudLevelName">Level 1</div>
        <button id="btnRestart" class="neu-btn icon-only">
            <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
        </button>
    </div>

    <!-- MAIN MENU -->
    <div id="menuScreen" class="screen">
        <h1>–ú–∞—Å—Ç–µ—Ä <span>–£–∑–ª–æ–≤</span></h1>
        <p class="subtitle">–î–∑–µ–Ω –≥–æ–ª–æ–≤–æ–ª–æ–º–∫–∞</p>
        
        <button id="btnPlay" class="neu-btn primary" style="width: 220px; margin-bottom: 15px;">
            –ò–ì–†–ê–¢–¨
        </button>

        <button id="btnOtherGamesMenu" class="neu-btn" style="width: 220px; margin-bottom: 15px; font-size: 0.9rem;">
            –î–†–£–ì–ò–ï –ò–ì–†–´
        </button>
        
        <div class="menu-controls">
            <button id="btnRules" class="neu-btn icon-only">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm1 17h-2v-2h2v2zm2.07-7.75l-.9.92C13.45 12.9 13 13.5 13 15h-2v-.5c0-1.1.45-2.1 1.17-2.83l1.24-1.26c.37-.36.59-.86.59-1.41 0-1.1-.9-2-2-2s-2 .9-2 2H8c0-2.21 1.79-4 4-4s4 1.79 4 4c0 .88-.36 1.68-.93 2.25z"/></svg>
            </button>
            <button id="btnSettings" class="neu-btn icon-only">
                <svg viewBox="0 0 24 24"><path d="M19.43 12.98c.04-.32.07-.64.07-.98s-.03-.66-.07-.98l2.11-1.65c.19-.15.24-.42.12-.64l-2-3.46c-.12-.22-.39-.3-.61-.22l-2.49 1c-.52-.4-1.08-.73-1.69-.98l-.38-2.65C14.46 2.18 14.25 2 14 2h-4c-.25 0-.46.18-.49.42l-.38 2.65c-.61.25-1.17.59-1.69.98l-2.49-1c-.23-.09-.49 0-.61.22l-2 3.46c-.13.22-.07.49.12.64l2.11 1.65c-.04.32-.07.65-.07.98s.03.66.07.98l-2.11 1.65c-.19.15-.24.42-.12.64l2 3.46c.12.22.39.3.61.22l2.49-1c.52.4 1.08.73 1.69.98l.38 2.65c.03.24.24.42.49.42h4c.25 0 .46-.18.49-.42l.38-2.65c.61-.25 1.17-.59 1.69-.98l2.49 1c.23.09.49 0 .61-.22l2-3.46c.12-.22.07-.49-.12-.64l-2.11-1.65zM12 15.5c-1.93 0-3.5-1.57-3.5-3.5s1.57-3.5 3.5-3.5 3.5 1.57 3.5 3.5-1.57 3.5-3.5 3.5z"/></svg>
            </button>
        </div>
    </div>

    <!-- LEVEL SELECT -->
    <div id="levelScreen" class="screen hidden">
        <div class="top-bar">
            <button id="btnBackLevel" class="neu-btn icon-only">
                <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
            </button>
            <span style="margin-left: 15px; font-weight: 800; font-size: 1.2rem; color: var(--text);">–†–µ–∂–∏–º—ã</span>
        </div>
        <div class="scroll-container" id="levelList">
            <!-- JS Generated -->
        </div>
    </div>

    <!-- OTHER GAMES SCREEN -->
    <div id="otherGamesScreen" class="screen hidden">
        <div class="top-bar">
            <button id="btnBackGames" class="neu-btn icon-only">
                <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
            </button>
            <span style="margin-left: 15px; font-weight: 800; font-size: 1.2rem; color: var(--text);">–î—Ä—É–≥–∏–µ –∏–≥—Ä—ã</span>
        </div>
        <div class="games-grid" id="gamesList">
            <!-- JS Generated -->
        </div>
    </div>

    <!-- SETTINGS MODAL -->
    <div id="settingsModal" class="screen hidden">
        <div class="modal-card">
            <h2 style="margin-bottom: 30px; color: var(--text); margin-top:0;">–ù–∞—Å—Ç—Ä–æ–π–∫–∏</h2>
            
            <div class="setting-row">
                <span>–ó–≤—É–∫</span>
                <div id="toggleSound" class="toggle-switch active"></div>
            </div>
            
            <div class="setting-row">
                <span>–í–∏–±—Ä–∞—Ü–∏—è</span>
                <div id="toggleVibro" class="toggle-switch active"></div>
            </div>
            
            <div class="setting-row">
                <span>–¢–µ–º–Ω–∞—è —Ç–µ–º–∞</span>
                <div id="toggleTheme" class="toggle-switch"></div>
            </div>

            <button id="btnCloseSettings" class="neu-btn" style="margin-top: 20px; width: 100%;">
                –ó–∞–∫—Ä—ã—Ç—å
            </button>
        </div>
    </div>

    <!-- RULES MODAL -->
    <div id="rulesModal" class="screen hidden" style="background: rgba(0,0,0,0.6); backdrop-filter: blur(10px); justify-content: center; align-items: center;">
        <div class="modal-card" style="max-width: 340px;">
            <h2 style="margin-top:0; color: var(--text);">–ö–∞–∫ –∏–≥—Ä–∞—Ç—å</h2>
            <canvas id="tutorialCanvas"></canvas>
            <p style="text-align: center; color: var(--text-light); margin-bottom: 20px; font-size: 0.9rem;">
                –ü–µ—Ä–µ—Ç–∞—Å–∫–∏–≤–∞–π —É–∑–ª—ã, —á—Ç–æ–±—ã —Ä–∞—Å–ø—É—Ç–∞—Ç—å –ª–∏–Ω–∏–∏. <br>
                –õ–∏–Ω–∏–∏ –Ω–µ –¥–æ–ª–∂–Ω—ã –ø–µ—Ä–µ—Å–µ–∫–∞—Ç—å—Å—è. <br>
                <span style="color: #ff7675">–ö—Ä–∞—Å–Ω—ã–π</span> - –ø–ª–æ—Ö–æ, <span style="color: #55efc4">–ó–µ–ª–µ–Ω—ã–π</span> - —Ö–æ—Ä–æ—à–æ.
            </p>
            <button id="btnCloseRules" class="neu-btn primary" style="width: 100%;">–ü–æ–Ω—è—Ç–Ω–æ</button>
        </div>
    </div>

    <!-- UNLOCK MODAL -->
    <div id="unlockModal" class="screen hidden" style="background: rgba(0,0,0,0.8); backdrop-filter: blur(8px); justify-content: center; align-items: center;">
        <div class="modal-card" style="text-align: center;">
            <div class="unlock-icon">üîì</div>
            <h2 style="color: var(--primary); margin-top:0;">–ù–æ–≤—ã–π —É—Ä–æ–≤–µ–Ω—å!</h2>
            <p style="color: var(--text); margin-bottom: 30px;">–ü–æ–∑–¥—Ä–∞–≤–ª—è–µ–º! –í—ã –ø—Ä–æ—à–ª–∏ —ç—Ç–æ—Ç —Ä–µ–∂–∏–º 10 —Ä–∞–∑ –∏ –æ—Ç–∫—Ä—ã–ª–∏ —Å–ª–µ–¥—É—é—â—É—é —Å–ª–æ–∂–Ω–æ—Å—Ç—å.</p>
            
            <button id="btnGoNextLevel" class="neu-btn primary" style="width: 100%; margin-bottom: 15px;">
                –ü–µ—Ä–µ–π—Ç–∏
            </button>
            <button id="btnStayLevel" class="neu-btn" style="width: 100%;">
                –û—Å—Ç–∞—Ç—å—Å—è
            </button>
        </div>
    </div>

    <!-- VICTORY SCREEN -->
    <div id="winScreen" class="screen overlay hidden" style="justify-content: center; align-items: center;">
        <div style="font-size: 4rem; margin-bottom: 10px;">‚ú®</div>
        <h2 style="color: var(--primary); font-size: 2rem; margin: 0;">–ò–¥–µ–∞–ª—å–Ω–æ!</h2>
        <p class="subtitle" id="winTimeDisplay">14.2 —Å–µ–∫</p>
        
        <button id="btnNextLevel" class="neu-btn primary" style="width: 200px; margin-bottom: 15px;">
            –î–∞–ª—å—à–µ
        </button>
        <button id="btnMenuWin" class="neu-btn" style="width: 200px;">
            –ú–µ–Ω—é
        </button>
    </div>

    <!-- PAUSE SCREEN -->
    <div id="pauseScreen" class="screen overlay hidden" style="justify-content: center; align-items: center;">
        <h2 style="margin-bottom: 30px; color: var(--text);">–ü–∞—É–∑–∞</h2>
        <button id="btnResume" class="neu-btn primary" style="width: 200px; margin-bottom: 15px;">
            –ü—Ä–æ–¥–æ–ª–∂–∏—Ç—å
        </button>
        <button id="btnExit" class="neu-btn" style="width: 200px;">
            –í—ã–π—Ç–∏
        </button>
    </div>

</div>

<script>
/**
 * SOFT TANGLE ENGINE v7.0 (Music & Audio Fixes)
 * - Music: bgMusic.mp3 added (loop, low volume).
 * - Fix: Forced audio context resume after ads.
 * - Logic: Pause/Resume music on tab switch (VKWebAppViewHide/Restore).
 */

// --- CONFIG ---
const CONFIG = {
    colors: {
        bg: '#ebf2f7',
        ropeTangled: '#ff7675',
        ropeFree: '#55efc4',
    },
    modes: [
        { id: 'warmup', name: '–†–∞–∑–º–∏–Ω–∫–∞', range: [4, 5] },
        { id: 'beginner', name: '–ù–æ–≤–∏—á–æ–∫', range: [6, 7] },
        { id: 'amateur', name: '–õ—é–±–∏—Ç–µ–ª—å', range: [8, 9] },
        { id: 'puzzle', name: '–ì–æ–ª–æ–≤–æ–ª–æ–º–∫–∞', range: [10, 11] },
        { id: 'hard', name: '–°–ª–æ–∂–Ω–æ', range: [12, 13] },
        { id: 'master', name: '–ú–∞—Å—Ç–µ—Ä', range: [14, 15] },
        { id: 'chaos', name: '–•–∞–æ—Å', range: [16, 20] }
    ],
    otherGames: [
        { name: '–ù–∞–π–¥–∏ —á–∏—Å–ª–∞', appId: 54240918, icon: 'icon1.png' },
        { name: '–ú–∞—Å—Ç–µ—Ä —Å–ª–∏—è–Ω–∏—è', appId: 54209536, icon: 'icon2.png' },
        { name: '–ü—è—Ç–Ω–∞—à–∫–∏', appId: 54195270, icon: 'icon3.png' },
        { name: '–°–∞–ø–µ—Ä', appId: 54160625, icon: 'icon4.png' },
        { name: 'Sort Puzzle', appId: 54143992, icon: 'icon5.png' },
        { name: 'Tower Blocks', appId: 53962513, icon: 'icon6.png' },
        { name: 'Bubble Shooter', appId: 54051411, icon: 'icon7.png' },
        { name: '2048', appId: 53965380, icon: 'icon8.png' },
        { name: 'Math Matrix', appId: 53970659, icon: 'icon9.png' }
    ]
};

// --- STATE ---
const STATE = {
    screen: 'menu',
    modeIdx: 0,
    nodes: [],
    edges: [],
    particles: [],
    draggedNode: null,
    isSolved: false,
    levelComplete: false,
    startTime: 0,
    levelsSinceAd: 0,
    progress: { 
        modeWins: new Array(CONFIG.modes.length).fill(0),
        activeLevels: {} 
    }, 
    settings: { sound: true, vibro: true, theme: 'light' },
    justUnlocked: -1
};

// --- AUDIO SYSTEM ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let actx = null;
const bgMusic = document.getElementById('bgMusic');
bgMusic.volume = 0.2; // Low volume

// Universal function to wake up both Web Audio API and HTML Audio
const restoreAudio = () => {
    // 1. Resume Web Audio
    if (actx && actx.state === 'suspended') {
        actx.resume().catch(() => {});
    }
    // 2. Resume Music if it should be playing
    if (STATE.settings.sound && bgMusic.paused) {
        bgMusic.play().catch(() => {});
    }
};

// Global listener to wake up audio on first interaction
const unlockAudio = () => {
    if (!actx) actx = new AudioCtx();
    restoreAudio();
    // Remove listeners once unlocked
    window.removeEventListener('touchstart', unlockAudio);
    window.removeEventListener('click', unlockAudio);
};
window.addEventListener('touchstart', unlockAudio, {passive: true});
window.addEventListener('click', unlockAudio);

const playSound = (type) => {
    if (!STATE.settings.sound) return;
    if (!actx) actx = new AudioCtx();
    
    if (actx.state === 'suspended') actx.resume();

    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const now = actx.currentTime;
    
    if (type === 'pop') {
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.1);
    } else if (type === 'win') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(300, now);
        osc.frequency.linearRampToValueAtTime(600, now + 0.3);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.6);
    } else if (type === 'click') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(800, now);
        osc.frequency.exponentialRampToValueAtTime(300, now + 0.05);
        gain.gain.setValueAtTime(0.05, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.05);
        osc.connect(gain);
        gain.connect(actx.destination);
        osc.start(now);
        osc.stop(now + 0.05);
        return;
    }
    osc.connect(gain);
    gain.connect(actx.destination);
    osc.start(now);
    osc.stop(now + 0.6);
};

// --- VK & ADS ---
const VK_APP = {
    user_id: null,
    is_ready: false,
    
    init: async function() {
        try {
            await vkBridge.send('VKWebAppInit');
            
            // Handle App Pausing/Resuming
            vkBridge.subscribe((e) => {
                if (e.detail.type === 'VKWebAppViewHide') {
                    // App went to background
                    bgMusic.pause();
                    if(actx) actx.suspend();
                }
                if (e.detail.type === 'VKWebAppViewRestore' || e.detail.type === 'VKWebAppAudioPaused') {
                    // App came back
                    restoreAudio();
                }
            });

            const user = await vkBridge.send('VKWebAppGetUserInfo');
            this.user_id = user.id;
            this.is_ready = true;
            
            await loadGameData();
            
            // Try to start music immediately (might work if VK allows)
            if (STATE.settings.sound) bgMusic.play().catch(()=>{});

            vkBridge.send('VKWebAppShowBannerAd', { banner_location: 'bottom' }).catch(console.log);
        } catch (e) {
            console.log('Offline mode');
            await loadGameData();
        }
    },

    vibrate: function(type) {
        if (!STATE.settings.vibro) return;
        if (this.is_ready) {
             const style = type === 'heavy' ? 'heavy' : (type === 'light' ? 'light' : 'medium');
             vkBridge.send('VKWebAppTapticImpactOccurred', { style }).catch(() => {});
        } else if (navigator.vibrate) {
             try { navigator.vibrate(type === 'success' ? [50,50] : 20); } catch(e){}
        }
    },

    checkInterstitial: function() {
        STATE.levelsSinceAd++;
        saveGameData();

        let interval = 3;
        if (STATE.modeIdx <= 1) interval = 10;
        else if (STATE.modeIdx <= 3) interval = 5;

        if (STATE.levelsSinceAd >= interval) {
            // Mute before ad
            bgMusic.pause();
            if(actx) actx.suspend();

            vkBridge.send('VKWebAppShowNativeAds', { ad_format: 'interstitial' })
                .then((data) => {
                    if (data.result) {
                        STATE.levelsSinceAd = 0;
                        saveGameData();
                    }
                    // CRITICAL: Resume audio after ad closes
                    restoreAudio();
                })
                .catch((error) => {
                    console.log("Ad error:", error);
                    // Also resume if error
                    restoreAudio();
                });
        }
    },
    
    openGame: function(appId) {
        vkBridge.send('VKWebAppOpenApp', { app_id: parseInt(appId) }).catch(console.log);
    }
};

// --- DATA STORAGE ---
async function saveGameData() {
    if (STATE.screen === 'game' && !STATE.isSolved) {
        STATE.progress.activeLevels[STATE.modeIdx] = {
            initialNodes: (STATE.progress.activeLevels[STATE.modeIdx]?.initialNodes || STATE.nodes.map(n => ({x: n.x, y: n.y}))),
            edges: STATE.edges,
            currentNodes: STATE.nodes.map(n => ({x: n.x, y: n.y}))
        };
    } 

    const data = {
        progress: STATE.progress,
        settings: STATE.settings,
        levelsSinceAd: STATE.levelsSinceAd
    };
    const json = JSON.stringify(data);
    localStorage.setItem('softTangleSave_v6', json);
    if (VK_APP.user_id) {
        const key = `softtangle_data_${VK_APP.user_id}`;
        vkBridge.send('VKWebAppStorageSet', { key: key, value: json }).catch(() => {});
    }
}

async function loadGameData() {
    let loadedData = null;
    if (VK_APP.user_id) {
        try {
            const key = `softtangle_data_${VK_APP.user_id}`;
            const resp = await vkBridge.send('VKWebAppStorageGet', { keys: [key] });
            if (resp.keys[0]?.value) loadedData = JSON.parse(resp.keys[0].value);
        } catch (e) {}
    }
    if (!loadedData) {
        const local = localStorage.getItem('softTangleSave_v6');
        if (local) loadedData = JSON.parse(local);
    }
    if (loadedData) {
        if (loadedData.progress) STATE.progress = loadedData.progress;
        if (!STATE.progress.modeWins) STATE.progress.modeWins = new Array(CONFIG.modes.length).fill(0);
        if (!STATE.progress.activeLevels) STATE.progress.activeLevels = {};
        
        if (loadedData.settings) STATE.settings = loadedData.settings;
        STATE.levelsSinceAd = loadedData.levelsSinceAd || 0;
    }
    applySettings();
}

function applySettings() {
    if (STATE.settings.theme === 'dark') document.body.classList.add('dark');
    else document.body.classList.remove('dark');
    
    // Apply sound settings immediately
    if (STATE.settings.sound) {
        bgMusic.play().catch(()=>{});
    } else {
        bgMusic.pause();
    }
    
    updateToggles();
}

// --- GRAPH LOGIC ---
class Node {
    constructor(x, y) {
        this.x = x; this.y = y; this.r = 20; this.vx = 0; this.vy = 0; this.isDragging = false;
    }
    update(w, h) {
        if (this.isDragging) return;
        this.vx *= 0.9; this.vy *= 0.9;
        this.x += this.vx; this.y += this.vy;
        const pad = 30;
        if (this.x < pad) { this.x = pad; this.vx *= -0.5; }
        if (this.x > w - pad) { this.x = w - pad; this.vx *= -0.5; }
        if (this.y < pad) { this.y = pad; this.vy *= -0.5; }
        if (this.y > h - pad) { this.y = h - pad; this.vy *= -0.5; }
    }
    draw(ctx) {
        // Shadow
        ctx.beginPath(); ctx.arc(this.x+3, this.y+3, this.r, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(0,0,0,0.2)'; ctx.fill();
        // Body
        ctx.beginPath(); ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        const grad = ctx.createRadialGradient(this.x-5, this.y-5, 2, this.x, this.y, this.r);
        const isDark = document.body.classList.contains('dark');
        grad.addColorStop(0, isDark ? '#a4b0be' : '#ffffff');
        grad.addColorStop(1, isDark ? '#57606f' : '#dfe6e9');
        ctx.fillStyle = grad; ctx.fill();
        // Ring
        if (this.isDragging) {
            ctx.lineWidth = 3;
            ctx.strokeStyle = STATE.isSolved ? CONFIG.colors.ropeFree : CONFIG.colors.ropeTangled;
            ctx.stroke();
        }
    }
}

const intersect = (p1, p2, p3, p4) => {
    const ccw = (a, b, c) => (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
    return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
};

// --- GAME ENGINE ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const resize = () => {
    const r = canvas.getBoundingClientRect();
    canvas.width = r.width * window.devicePixelRatio;
    canvas.height = r.height * window.devicePixelRatio;
    ctx.scale(window.devicePixelRatio, window.devicePixelRatio);
    canvas.logicalWidth = r.width;
    canvas.logicalHeight = r.height;
};
window.addEventListener('resize', resize);
setTimeout(resize, 100);

const startLevel = (idx) => {
    STATE.modeIdx = idx;
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('hud').classList.remove('hidden');
    STATE.screen = 'game';
    resize();

    // Check for saved state for THIS mode
    const saved = STATE.progress.activeLevels[idx];
    if (saved) {
        // Restore Level
        STATE.nodes = saved.currentNodes.map(n => new Node(n.x, n.y));
        STATE.edges = saved.edges;
        STATE.particles = [];
        STATE.startTime = Date.now();
        STATE.isSolved = false;
        STATE.levelComplete = false;
        updateHud();
    } else {
        // New Level
        generateLevel();
    }
};

const generateLevel = () => {
    const mode = CONFIG.modes[STATE.modeIdx];
    const count = Math.floor(Math.random() * (mode.range[1] - mode.range[0] + 1)) + mode.range[0];
    let attempt = 0, valid = false;
    
    while (!valid && attempt < 20) {
        attempt++;
        STATE.nodes = []; STATE.edges = []; STATE.particles = [];
        const cx = canvas.logicalWidth/2, cy = canvas.logicalHeight/2;
        const rad = Math.min(cx, cy) * 0.65;
        
        for(let i=0; i<count; i++) {
            const a = (i/count)*Math.PI*2;
            STATE.nodes.push(new Node(cx + Math.cos(a)*rad, cy + Math.sin(a)*rad));
            STATE.edges.push([i, (i+1)%count]);
        }
        if(count > 5) {
            for(let k=0; k<Math.floor(count/2); k++) {
                const i1 = Math.floor(Math.random()*count);
                const i2 = (i1 + 2 + Math.floor(Math.random()*(count-4))) % count;
                if(Math.abs(i1-i2)>1) STATE.edges.push([i1, i2]);
            }
        }
        STATE.nodes.forEach(n => {
            n.x = 40 + Math.random()*(canvas.logicalWidth-80);
            n.y = 80 + Math.random()*(canvas.logicalHeight-160);
        });
        
        const check = checkStatus();
        if(check.collisions > 0 || attempt > 15) valid = true;
    }
    STATE.startTime = Date.now();
    STATE.isSolved = false;
    STATE.levelComplete = false;
    
    // Save new INITIAL state for this mode immediately
    STATE.progress.activeLevels[STATE.modeIdx] = {
        initialNodes: STATE.nodes.map(n => ({x: n.x, y: n.y})),
        edges: STATE.edges,
        currentNodes: STATE.nodes.map(n => ({x: n.x, y: n.y}))
    };
    saveGameData();
    
    updateHud();
};

const checkStatus = () => {
    let collisions = 0;
    const status = new Array(STATE.edges.length).fill(false);
    for(let i=0; i<STATE.edges.length; i++) {
        for(let j=i+1; j<STATE.edges.length; j++) {
            const [a1,a2] = STATE.edges[i], [b1,b2] = STATE.edges[j];
            if(a1===b1 || a1===b2 || a2===b1 || a2===b2) continue;
            if(intersect(STATE.nodes[a1], STATE.nodes[a2], STATE.nodes[b1], STATE.nodes[b2])) {
                status[i] = true; status[j] = true; collisions++;
            }
        }
    }
    return {collisions, status};
};

const loop = () => {
    requestAnimationFrame(loop);
    if(STATE.screen !== 'game' && STATE.screen !== 'win') return;
    ctx.clearRect(0,0,canvas.logicalWidth, canvas.logicalHeight);
    
    STATE.nodes.forEach(n => n.update(canvas.logicalWidth, canvas.logicalHeight));
    const {collisions, status} = checkStatus();
    STATE.isSolved = collisions === 0;
    
    if(STATE.isSolved && !STATE.draggedNode && !STATE.levelComplete) {
        STATE.levelComplete = true;
        winLevel();
    }
    
    ctx.lineCap = 'round'; ctx.lineJoin = 'round';
    STATE.edges.forEach((e, i) => {
        const n1 = STATE.nodes[e[0]], n2 = STATE.nodes[e[1]];
        // Rope
        ctx.beginPath(); ctx.moveTo(n1.x, n1.y); ctx.lineTo(n2.x, n2.y);
        ctx.lineWidth = 6;
        ctx.strokeStyle = status[i] ? CONFIG.colors.ropeTangled : CONFIG.colors.ropeFree;
        ctx.stroke();
        // Highlight
        ctx.lineWidth = 2; ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.stroke();
    });
    STATE.nodes.forEach(n => n.draw(ctx));
    
    // Particles
    STATE.particles.forEach((p, i) => {
        p.x+=p.vx; p.y+=p.vy; p.vy+=0.1; p.life-=0.02;
        ctx.fillStyle = p.color; ctx.globalAlpha = Math.max(0, p.life);
        ctx.fillRect(p.x, p.y, 5, 5); ctx.globalAlpha = 1;
        if(p.life<=0) STATE.particles.splice(i,1);
    });
};

const winLevel = () => {
    const elapsed = ((Date.now() - STATE.startTime)/1000).toFixed(1);
    playSound('win');
    VK_APP.vibrate('success');
    
    STATE.progress.modeWins[STATE.modeIdx]++;
    
    // Clear saved state for this mode because we won it!
    delete STATE.progress.activeLevels[STATE.modeIdx];
    
    const nextIdx = STATE.modeIdx + 1;
    let unlockedNew = false;
    if (nextIdx < CONFIG.modes.length) {
        if (STATE.progress.modeWins[STATE.modeIdx] === 10) {
            unlockedNew = true;
            STATE.justUnlocked = nextIdx;
        }
    }

    saveGameData();
    VK_APP.checkInterstitial();

    for(let i=0; i<50; i++) {
        STATE.particles.push({
            x: canvas.logicalWidth/2, y: canvas.logicalHeight/2,
            vx: (Math.random()-0.5)*15, vy: (Math.random()-0.5)*15,
            color: ['#ff7675','#55efc4','#6c5ce7'][Math.floor(Math.random()*3)], life:1
        });
    }

    setTimeout(() => {
        if (unlockedNew) {
            goToScreen('unlockModal');
        } else {
            document.getElementById('winTimeDisplay').innerText = `${elapsed} —Å–µ–∫`;
            goToScreen('winScreen');
        }
    }, 1200);
};

// --- TUTORIAL ANIMATION ---
const initTutorial = () => {
    const tCanvas = document.getElementById('tutorialCanvas');
    const tCtx = tCanvas.getContext('2d');
    const dpr = window.devicePixelRatio || 1;
    const rect = tCanvas.getBoundingClientRect();
    tCanvas.width = rect.width * dpr;
    tCanvas.height = rect.height * dpr;
    tCtx.scale(dpr, dpr);
    
    let tFrame = 0;
    // 4 nodes with loop connections: 0-1, 1-2, 2-3, 3-0
    let tNodes = [
        {x: 50, y: 50, tx: 50, ty: 50},   // 0: TL
        {x: 150, y: 150, tx: 150, ty: 150}, // 1: BR
        {x: 150, y: 50, tx: 150, ty: 50},   // 2: TR
        {x: 50, y: 150, tx: 50, ty: 150}    // 3: BL
    ];
    
    const drawT = () => {
        if (STATE.screen !== 'rulesModal') return;
        requestAnimationFrame(drawT);
        tCtx.clearRect(0,0,200,200);
        tFrame++;
        
        if (tFrame % 240 === 0) {
            // Untangle (Square)
            tNodes[1].tx = 150; tNodes[1].ty = 150; // 1 to BR
            tNodes[2].tx = 150; tNodes[2].ty = 50;  // 2 to TR
        } else if (tFrame % 240 === 120) {
            // Tangle (Cross)
            tNodes[1].tx = 150; tNodes[1].ty = 50;  // 1 to TR
            tNodes[2].tx = 150; tNodes[2].ty = 150; // 2 to BR
        }
        
        tNodes.forEach(n => {
            n.x += (n.tx - n.x) * 0.05;
            n.y += (n.ty - n.y) * 0.05;
        });
        
        const p0=tNodes[0], p1=tNodes[1], p2=tNodes[2], p3=tNodes[3];
        const edges = [
            [p0, p2], // 0-2
            [p2, p1], // 2-1
            [p1, p3], // 1-3
            [p3, p0]  // 3-0
        ];

        tCtx.lineWidth = 6;
        tCtx.lineCap = 'round';

        edges.forEach((edge, i) => {
            const a = edge[0];
            const b = edge[1];
            
            let isBad = false;
            for(let j=0; j<edges.length; j++) {
                 if (i===j) continue;
                 if (edges[j][0]===a || edges[j][0]===b || edges[j][1]===a || edges[j][1]===b) continue;
                 
                 if (intersect(a, b, edges[j][0], edges[j][1])) {
                     isBad = true;
                     break;
                 }
            }
            
            tCtx.strokeStyle = isBad ? CONFIG.colors.ropeTangled : CONFIG.colors.ropeFree;
            tCtx.beginPath();
            tCtx.moveTo(a.x, a.y);
            tCtx.lineTo(b.x, b.y);
            tCtx.stroke();
        });
        
        tNodes.forEach(n => {
            tCtx.beginPath(); tCtx.arc(n.x, n.y, 8, 0, Math.PI*2);
            tCtx.fillStyle = document.body.classList.contains('dark') ? '#a4b0be' : '#fff'; 
            tCtx.fill();
        });
    };
    drawT();
};

// --- INPUT & UI ---
const getPos = (e) => {
    const r = canvas.getBoundingClientRect();
    const x = (e.touches?e.touches[0].clientX:e.clientX)-r.left;
    const y = (e.touches?e.touches[0].clientY:e.clientY)-r.top;
    return {x: x*(canvas.logicalWidth/r.width), y: y*(canvas.logicalHeight/r.height)};
};
canvas.addEventListener('mousedown', e => {
    if(STATE.screen!=='game') return;
    const {x,y} = getPos(e);
    for(let n of STATE.nodes) if(Math.hypot(n.x-x, n.y-y)<30) {
        STATE.draggedNode=n; n.isDragging=true; playSound('pop'); VK_APP.vibrate('light'); break;
    }
});
canvas.addEventListener('mousemove', e => {
    if(!STATE.draggedNode) return;
    const {x,y} = getPos(e);
    STATE.draggedNode.x += (x-STATE.draggedNode.x)*0.6;
    STATE.draggedNode.y += (y-STATE.draggedNode.y)*0.6;
});
window.addEventListener('mouseup', () => { 
    if(STATE.draggedNode) { 
        STATE.draggedNode.isDragging=false; 
        STATE.draggedNode=null; 
        saveGameData(); 
    } 
});
canvas.addEventListener('touchstart', e => {
    if(STATE.screen!=='game') return;
    e.preventDefault();
    const {x,y} = getPos(e);
    for(let n of STATE.nodes) if(Math.hypot(n.x-x, n.y-y)<30) {
        STATE.draggedNode=n; n.isDragging=true; playSound('pop'); VK_APP.vibrate('light'); break;
    }
}, {passive:false});
canvas.addEventListener('touchmove', e => {
    if(!STATE.draggedNode) return;
    e.preventDefault();
    const {x,y} = getPos(e);
    STATE.draggedNode.x += (x-STATE.draggedNode.x)*0.6;
    STATE.draggedNode.y += (y-STATE.draggedNode.y)*0.6;
}, {passive:false});
window.addEventListener('touchend', () => { 
    if(STATE.draggedNode) { 
        STATE.draggedNode.isDragging=false; 
        STATE.draggedNode=null; 
        saveGameData(); 
    } 
});

// --- NAVIGATION ---
const goToScreen = (id) => {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('hud').classList.add('hidden');
    document.getElementById(id).classList.remove('hidden');
    STATE.screen = id === 'menuScreen' ? 'menu' : id;
    
    if(id === 'levelScreen') renderLevels();
    if(id === 'otherGamesScreen') renderOtherGames();
    if(id === 'rulesModal') { STATE.screen = 'rulesModal'; initTutorial(); }
    if(id === 'menuScreen') {
         if(VK_APP.is_ready) vkBridge.send('VKWebAppShowBannerAd', { banner_location: 'bottom' }).catch(()=>{});
    }
};

const startGame = (idx) => {
    startLevel(idx);
};

const updateHud = () => document.getElementById('hudLevelName').innerText = CONFIG.modes[STATE.modeIdx].name;

const renderLevels = () => {
    const list = document.getElementById('levelList');
    list.innerHTML = '';
    CONFIG.modes.forEach((m, i) => {
        const prevWins = i === 0 ? 999 : STATE.progress.modeWins[i-1];
        const locked = prevWins < 10;
        const currentWins = STATE.progress.modeWins[i];
        
        let lockText = "–ó–ê–ö–†–´–¢–û";
        if (locked) {
            const prevName = CONFIG.modes[i-1].name;
            lockText = `–ù—É–∂–Ω–æ 10 –ø–æ–±–µ–¥ –≤ ${prevName}`;
        }

        const displayLevel = currentWins + 1;

        const el = document.createElement('div');
        el.className = `level-card ${locked ? 'locked' : ''}`;
        el.innerHTML = `
            <div class="lvl-info">
                <h3>${m.name}</h3>
                <p>${locked ? lockText : `${m.range[0]}-${m.range[1]} –£–∑–ª–æ–≤`}</p>
            </div>
            <div class="status-badge ${!locked ? 'open' : ''}">
                ${locked ? '–ó–ê–ö–†–´–¢–û' : `–£—Ä–æ–≤–µ–Ω—å: ${displayLevel}`}
            </div>
        `;
        el.onclick = () => {
            if(locked) { VK_APP.vibrate('error'); return; }
            playSound('click'); // Sound on level click
            startGame(i);
        };
        list.appendChild(el);
    });
};

const renderOtherGames = () => {
    const list = document.getElementById('gamesList');
    list.innerHTML = '';
    CONFIG.otherGames.forEach(g => {
        const el = document.createElement('div');
        el.className = 'game-item';
        el.innerHTML = `<div class="game-icon"><img src="${g.icon}" alt=""></div><div class="game-name">${g.name}</div>`;
        el.onclick = () => {
            playSound('click'); // Sound on game item click
            VK_APP.openGame(g.appId);
        };
        list.appendChild(el);
    });
};

// Global Button Click Sound Init
const initButtonSounds = () => {
    document.querySelectorAll('.neu-btn').forEach(btn => {
        btn.addEventListener('click', () => {
            playSound('click');
        });
    });
};

// Buttons Logic
document.getElementById('btnPlay').onclick = () => goToScreen('levelScreen');
document.getElementById('btnOtherGamesMenu').onclick = () => goToScreen('otherGamesScreen');
document.getElementById('btnSettings').onclick = () => document.getElementById('settingsModal').classList.remove('hidden');
document.getElementById('btnRules').onclick = () => goToScreen('rulesModal');

document.getElementById('btnCloseSettings').onclick = () => document.getElementById('settingsModal').classList.add('hidden');
document.getElementById('btnCloseRules').onclick = () => goToScreen('menuScreen');

document.getElementById('btnBackLevel').onclick = () => goToScreen('menuScreen');
document.getElementById('btnBackGames').onclick = () => goToScreen('menuScreen');

document.getElementById('btnPause').onclick = () => goToScreen('pauseScreen');
document.getElementById('btnResume').onclick = () => {
    document.getElementById('pauseScreen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    STATE.screen = 'game';
};

document.getElementById('btnRestart').onclick = () => {
    const saved = STATE.progress.activeLevels[STATE.modeIdx];
    if (saved) {
        STATE.nodes = saved.initialNodes.map(n => new Node(n.x, n.y));
        saved.currentNodes = saved.initialNodes.map(n => ({x:n.x, y:n.y}));
        STATE.startTime = Date.now();
        STATE.isSolved = false;
        STATE.levelComplete = false;
        saveGameData();
    } else {
        generateLevel();
    }
};

document.getElementById('btnExit').onclick = () => {
    saveGameData(); 
    goToScreen('menuScreen');
};
document.getElementById('btnMenuWin').onclick = () => goToScreen('menuScreen');
document.getElementById('btnNextLevel').onclick = () => {
    document.getElementById('winScreen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    STATE.screen = 'game';
    generateLevel(); 
};

document.getElementById('btnGoNextLevel').onclick = () => {
    document.getElementById('unlockModal').classList.add('hidden');
    startLevel(STATE.justUnlocked);
};
document.getElementById('btnStayLevel').onclick = () => {
    document.getElementById('unlockModal').classList.add('hidden');
    goToScreen('levelScreen');
};

// Settings Toggles
const updateToggles = () => {
    document.getElementById('toggleSound').className = `toggle-switch ${STATE.settings.sound ? 'active' : ''}`;
    document.getElementById('toggleVibro').className = `toggle-switch ${STATE.settings.vibro ? 'active' : ''}`;
    document.getElementById('toggleTheme').className = `toggle-switch ${STATE.settings.theme === 'dark' ? 'active' : ''}`;
};
document.getElementById('toggleSound').onclick = () => {
    STATE.settings.sound = !STATE.settings.sound;
    
    // Toggle music based on sound setting
    if (STATE.settings.sound) {
        if(actx) actx.resume();
        bgMusic.play().catch(()=>{});
    } else {
        bgMusic.pause();
    }

    playSound('click'); 
    saveGameData(); updateToggles();
};
document.getElementById('toggleVibro').onclick = () => {
    STATE.settings.vibro = !STATE.settings.vibro;
    VK_APP.vibrate('medium');
    playSound('click');
    saveGameData(); updateToggles();
};
document.getElementById('toggleTheme').onclick = () => {
    STATE.settings.theme = STATE.settings.theme === 'dark' ? 'light' : 'dark';
    playSound('click');
    applySettings(); saveGameData();
};

// Start
resize();
initButtonSounds();
VK_APP.init();
loop();
</script>
</body>
</html>