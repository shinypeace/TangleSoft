<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Soft Tangle: Zen Puzzle</title>
    
    <!-- VK Bridge -->
    <script src="https://unpkg.com/@vkontakte/vk-bridge/dist/browser.min.js"></script>

    <style>
        @import url('https://fonts.googleapis.com/css2?family=Nunito:wght@600;800;900&display=swap');

        :root {
            --bg-color: #ebf2f7;
            --app-width: 380px;
            --primary: #6c5ce7;
            --primary-dark: #5849be;
            --text: #2d3436;
            --text-light: #636e72;
            --shadow-light: -4px -4px 12px #ffffff;
            --shadow-dark: 4px 4px 12px #d1d9e6;
            --radius-main: 24px;
            --radius-btn: 16px;
        }

        * {
            box-sizing: border-box;
            touch-action: none;
            user-select: none;
            -webkit-tap-highlight-color: transparent;
            outline: none;
        }

        body {
            margin: 0;
            height: 100vh;
            width: 100vw;
            background-color: #d1d9e6;
            font-family: 'Nunito', sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            overflow: hidden;
        }

        /* FRAME */
        #app-frame {
            position: relative;
            width: 100%;
            max-width: var(--app-width);
            height: 100%;
            max-height: 850px;
            background: var(--bg-color);
            box-shadow: 0 30px 60px rgba(0,0,0,0.15);
            overflow: hidden;
            display: flex;
            flex-direction: column;
        }

        @media (min-width: 450px) {
            #app-frame {
                height: 90vh;
                border-radius: 32px;
                border: 6px solid #f5f7fa;
            }
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
            cursor: grab;
        }
        canvas:active { cursor: grabbing; }

        /* UI ARCHITECTURE */
        .screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: flex;
            flex-direction: column;
            background: var(--bg-color);
            z-index: 10;
            transition: opacity 0.3s ease, transform 0.3s ease;
            padding: 20px;
        }

        .screen.hidden {
            opacity: 0;
            pointer-events: none;
            transform: scale(0.96);
        }
        
        .screen.overlay {
            background: rgba(235, 242, 247, 0.95);
            backdrop-filter: blur(5px);
        }

        .pointer-auto { pointer-events: auto; }

        /* TYPOGRAPHY */
        h1 {
            font-size: 2.5rem;
            color: var(--text);
            margin: 0 0 5px 0;
            line-height: 1;
            text-align: center;
        }
        h1 span { color: var(--primary); }
        
        .subtitle {
            color: var(--text-light);
            font-size: 0.95rem;
            margin-bottom: 30px;
            text-align: center;
            font-weight: 600;
        }

        /* COMPONENTS */
        .neu-btn {
            background: var(--bg-color);
            border: none;
            border-radius: var(--radius-btn);
            padding: 14px;
            box-shadow: var(--shadow-dark), var(--shadow-light);
            color: var(--text);
            font-weight: 800;
            font-family: 'Nunito', sans-serif;
            cursor: pointer;
            transition: all 0.15s ease;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 1rem;
            position: relative;
        }

        .neu-btn:active {
            box-shadow: inset 4px 4px 8px #d1d9e6, inset -4px -4px 8px #ffffff;
            transform: translateY(1px);
            color: var(--primary);
        }
        
        .neu-btn.primary {
            background: var(--primary);
            color: white;
            box-shadow: 6px 6px 16px rgba(108, 92, 231, 0.3), -6px -6px 16px #ffffff;
        }
        .neu-btn.primary:active {
            background: var(--primary-dark);
            box-shadow: inset 4px 4px 8px rgba(0,0,0,0.2);
            color: white;
        }

        .neu-btn.icon-only {
            width: 44px;
            height: 44px;
            padding: 0;
            border-radius: 50%;
        }
        .neu-btn svg { width: 22px; height: 22px; fill: currentColor; }

        /* Main Menu */
        #menuScreen {
            justify-content: center;
            align-items: center;
        }
        .menu-controls {
            display: flex;
            gap: 20px;
            margin-top: 20px;
        }

        /* Level Select - Compact Design */
        #levelScreen { padding-top: 70px; }
        .top-bar {
            position: absolute;
            top: 0; left: 0; right: 0;
            padding: 15px;
            display: flex;
            align-items: center;
            justify-content: flex-start;
            background: linear-gradient(180deg, var(--bg-color) 85%, transparent 100%);
            z-index: 2;
        }
        .scroll-container {
            flex: 1;
            overflow-y: auto;
            width: 100%;
            padding: 5px 4px;
            -webkit-overflow-scrolling: touch;
        }
        .scroll-container::-webkit-scrollbar { display: none; }

        .level-card {
            background: var(--bg-color);
            border-radius: 16px; /* Slightly smaller radius */
            padding: 12px 16px; /* Compact padding */
            margin-bottom: 12px; /* Compact margin */
            box-shadow: var(--shadow-dark), var(--shadow-light);
            cursor: pointer;
            transition: transform 0.2s;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        .level-card:active { transform: scale(0.98); }
        .level-card.locked { opacity: 0.5; filter: grayscale(0.8); }
        
        .lvl-info h3 { margin: 0; font-size: 1rem; color: var(--text); }
        .lvl-info p { margin: 2px 0 0; font-size: 0.8rem; color: var(--text-light); }
        
        .status-badge {
            font-size: 0.75rem;
            font-weight: 800;
            padding: 4px 10px;
            border-radius: 10px;
            background: #dfe6e9;
            color: var(--text-light);
            min-width: 80px;
            text-align: center;
        }
        .status-badge.open { background: #dff9fb; color: #00b894; }

        /* Other Games Screen */
        #otherGamesScreen { padding-top: 70px; }
        .games-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            padding: 10px 4px;
            overflow-y: auto;
        }
        .game-item {
            display: flex;
            flex-direction: column;
            align-items: center;
            cursor: pointer;
        }
        .game-icon {
            width: 70px;
            height: 70px;
            border-radius: 18px;
            background: #fff;
            box-shadow: var(--shadow-dark), var(--shadow-light);
            overflow: hidden;
            margin-bottom: 8px;
            transition: transform 0.2s;
        }
        .game-item:active .game-icon { transform: scale(0.95); }
        .game-icon img { width: 100%; height: 100%; object-fit: cover; }
        .game-name {
            font-size: 0.75rem;
            font-weight: 700;
            color: var(--text);
            text-align: center;
            line-height: 1.2;
        }

        /* HUD */
        #hud {
            position: absolute;
            top: 0; left: 0; width: 100%;
            padding: 15px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            pointer-events: none;
            z-index: 5;
        }
        #hud button { pointer-events: auto; }
        .level-pill {
            background: var(--bg-color);
            padding: 6px 14px;
            border-radius: 20px;
            box-shadow: inset 3px 3px 6px #d1d9e6, inset -3px -3px 6px #ffffff;
            font-weight: 800;
            color: var(--primary);
            font-size: 0.9rem;
        }

        /* Settings Modal */
        #settingsModal {
            justify-content: center;
            align-items: center;
            background: rgba(235, 242, 247, 0.98);
        }
        .setting-row {
            display: flex;
            justify-content: space-between;
            align-items: center;
            width: 100%;
            max-width: 280px;
            margin-bottom: 24px;
            font-weight: 700;
            color: var(--text);
        }
        .toggle-switch {
            width: 50px;
            height: 28px;
            background: #d1d9e6;
            border-radius: 14px;
            position: relative;
            cursor: pointer;
            box-shadow: inset 2px 2px 5px rgba(0,0,0,0.1);
            transition: background 0.3s;
        }
        .toggle-switch::after {
            content: '';
            position: absolute;
            top: 3px; left: 3px;
            width: 22px; height: 22px;
            background: white;
            border-radius: 50%;
            box-shadow: 1px 1px 3px rgba(0,0,0,0.2);
            transition: transform 0.3s;
        }
        .toggle-switch.active { background: var(--primary); }
        .toggle-switch.active::after { transform: translateX(22px); }

    </style>
</head>
<body>

<div id="app-frame">
    
    <!-- GAME CANVAS -->
    <canvas id="gameCanvas"></canvas>

    <!-- HUD -->
    <div id="hud" class="hidden">
        <button id="btnPause" class="neu-btn icon-only">
            <svg viewBox="0 0 24 24"><path d="M6 19h4V5H6v14zm8-14v14h4V5h-4z"/></svg>
        </button>
        <div class="level-pill" id="hudLevelName">Level 1</div>
        <button id="btnRestart" class="neu-btn icon-only">
            <svg viewBox="0 0 24 24"><path d="M17.65 6.35C16.2 4.9 14.21 4 12 4c-4.42 0-7.99 3.58-7.99 8s3.57 8 7.99 8c3.73 0 6.84-2.55 7.73-6h-2.08c-.82 2.33-3.04 4-5.65 4-3.31 0-6-2.69-6-6s2.69-6 6-6c1.66 0 3.14.69 4.22 1.78L13 11h7V4l-2.35 2.35z"/></svg>
        </button>
    </div>

    <!-- MAIN MENU -->
    <div id="menuScreen" class="screen">
        <h1>Soft <span>Tangle</span></h1>
        <p class="subtitle">Zen Puzzle Experience</p>
        
        <button id="btnPlay" class="neu-btn primary" style="width: 220px; margin-bottom: 15px;">
            ИГРАТЬ
        </button>

        <button id="btnOtherGamesMenu" class="neu-btn" style="width: 220px; margin-bottom: 15px; font-size: 0.9rem;">
            ДРУГИЕ ИГРЫ
        </button>
        
        <div class="menu-controls">
            <button id="btnSettings" class="neu-btn icon-only">
                <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.3.06-.61.06-.94 0-.32-.02-.64-.07-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
            </button>
        </div>
    </div>

    <!-- LEVEL SELECT -->
    <div id="levelScreen" class="screen hidden">
        <div class="top-bar">
            <button id="btnBackLevel" class="neu-btn icon-only">
                <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
            </button>
            <span style="margin-left: 15px; font-weight: 800; font-size: 1.2rem; color: var(--text);">Режимы</span>
        </div>
        <div class="scroll-container" id="levelList">
            <!-- JS Generated -->
        </div>
    </div>

    <!-- OTHER GAMES SCREEN -->
    <div id="otherGamesScreen" class="screen hidden">
        <div class="top-bar">
            <button id="btnBackGames" class="neu-btn icon-only">
                <svg viewBox="0 0 24 24"><path d="M20 11H7.83l5.59-5.59L12 4l-8 8 8 8 1.41-1.41L7.83 13H20v-2z"/></svg>
            </button>
            <span style="margin-left: 15px; font-weight: 800; font-size: 1.2rem; color: var(--text);">Другие игры</span>
        </div>
        <div class="games-grid" id="gamesList">
            <!-- JS Generated -->
        </div>
    </div>

    <!-- SETTINGS MODAL -->
    <div id="settingsModal" class="screen hidden">
        <h2 style="margin-bottom: 40px; color: var(--text);">Настройки</h2>
        
        <div class="setting-row">
            <span>Звук</span>
            <div id="toggleSound" class="toggle-switch active"></div>
        </div>
        
        <div class="setting-row">
            <span>Вибрация</span>
            <div id="toggleVibro" class="toggle-switch active"></div>
        </div>

        <button id="btnCloseSettings" class="neu-btn" style="margin-top: 40px; width: 150px;">
            Закрыть
        </button>
    </div>

    <!-- VICTORY SCREEN -->
    <div id="winScreen" class="screen overlay hidden" style="justify-content: center; align-items: center;">
        <div style="font-size: 4rem; margin-bottom: 10px;">✨</div>
        <h2 style="color: var(--primary); font-size: 2rem; margin: 0;">Идеально!</h2>
        <p class="subtitle" id="winTimeDisplay">14.2 сек</p>
        
        <button id="btnNextLevel" class="neu-btn primary" style="width: 200px; margin-bottom: 15px;">
            Дальше
        </button>
        <button id="btnMenuWin" class="neu-btn" style="width: 200px;">
            Меню
        </button>
    </div>

    <!-- PAUSE SCREEN -->
    <div id="pauseScreen" class="screen overlay hidden" style="justify-content: center; align-items: center;">
        <h2 style="margin-bottom: 30px; color: var(--text);">Пауза</h2>
        <button id="btnResume" class="neu-btn primary" style="width: 200px; margin-bottom: 15px;">
            Продолжить
        </button>
        <button id="btnExit" class="neu-btn" style="width: 200px;">
            Выйти
        </button>
    </div>

</div>

<script>
/**
 * SOFT TANGLE ENGINE v3.0
 * Features: 7 Modes (Compact), VK Integration, Ads, Cloud Save
 */

// --- VK & CONFIG ---
const VK_APP = {
    user_id: null,
    is_ready: false,
    
    init: async function() {
        try {
            await vkBridge.send('VKWebAppInit');
            const user = await vkBridge.send('VKWebAppGetUserInfo');
            this.user_id = user.id;
            this.is_ready = true;
            
            // Load data after we have user_id
            await loadGameData();
            
            // Show banner always
            vkBridge.send('VKWebAppShowBannerAd', { banner_location: 'bottom' }).catch(console.log);
        } catch (e) {
            console.warn('VK Init Error (Offline mode?):', e);
            // Fallback load for local dev
            await loadGameData();
        }
    },

    vibrate: function(type) {
        if (!STATE.settings.vibro) return;
        
        // Попытка использовать нативную вибрацию VK (она работает лучше в iframe)
        if (this.is_ready) {
             // type: 'light', 'medium', 'heavy', 'success', 'error', 'warning'
             if (['success', 'error', 'warning'].includes(type)) {
                 vkBridge.send('VKWebAppTapticNotificationOccurred', { type }).catch(() => {});
             } else {
                 // Mapping for impact
                 const style = type === 'heavy' ? 'heavy' : (type === 'light' ? 'light' : 'medium');
                 vkBridge.send('VKWebAppTapticImpactOccurred', { style }).catch(() => {});
             }
        }
        
        // Fallback for browser dev
        if (navigator.vibrate) {
             try { 
                 const ms = type === 'success' ? [50, 50, 100] : (type === 'light' ? 10 : 20);
                 navigator.vibrate(ms); 
             } catch(e){}
        }
    },

    checkInterstitial: function() {
        STATE.levelsSinceAd++;
        if (STATE.levelsSinceAd >= 3) {
            vkBridge.send('VKWebAppShowInterstitialAd')
                .then(() => { STATE.levelsSinceAd = 0; saveGameData(); })
                .catch(() => {});
        } else {
            saveGameData();
        }
    },
    
    openGame: function(appId) {
        vkBridge.send('VKWebAppOpenApp', { app_id: parseInt(appId) }).catch(console.log);
    }
};

const CONFIG = {
    colors: {
        bg: '#ebf2f7',
        ropeTangled: '#ff7675',
        ropeFree: '#55efc4',
        node: '#ffffff',
        nodeShadow: '#d1d9e6'
    },
    // 7 Режимов с шагом в 2 веревки
    modes: [
        { id: 'warmup', name: 'Разминка', range: [4, 5], unlock: 0 },
        { id: 'beginner', name: 'Новичок', range: [6, 7], unlock: 3 },
        { id: 'amateur', name: 'Любитель', range: [8, 9], unlock: 8 },
        { id: 'puzzle', name: 'Головоломка', range: [10, 11], unlock: 15 },
        { id: 'hard', name: 'Сложно', range: [12, 13], unlock: 25 },
        { id: 'master', name: 'Мастер', range: [14, 15], unlock: 40 },
        { id: 'chaos', name: 'Хаос', range: [16, 20], unlock: 60 }
    ],
    otherGames: [
        { name: 'Bubble Shooter', appId: 54051411, icon: 'icon1.png' },
        { name: 'Тетрис', appId: 54051413, icon: 'icon2.png' },
        { name: 'Tower Blocks', appId: 53962513, icon: 'icon3.png' },
        { name: 'Блок Про', appId: 53936296, icon: 'icon4.png' },
        { name: 'Филворды', appId: 53867134, icon: 'icon5.png' },
        { name: 'Словли', appId: 53861990, icon: 'icon6.png' },
        { name: 'Brick Balls', appId: 54023580, icon: 'icon7.png' },
        { name: '2048', appId: 53965380, icon: 'icon8.png' },
        { name: 'Math Matrix', appId: 53970659, icon: 'icon9.png' }
    ]
};

// --- GAME STATE ---
const STATE = {
    screen: 'menu',
    modeIdx: 0,
    nodes: [],
    edges: [],
    particles: [],
    draggedNode: null,
    isSolved: false,
    levelComplete: false,
    startTime: 0,
    levelsSinceAd: 0, // Track ads
    progress: { wins: 0 }, // Default, overwritten by load
    settings: { sound: true, vibro: true }
};

// --- STORAGE ---
async function saveGameData() {
    const data = {
        progress: STATE.progress,
        settings: STATE.settings,
        levelsSinceAd: STATE.levelsSinceAd
    };
    const json = JSON.stringify(data);
    
    // Local save
    localStorage.setItem('softTangleSave_v3', json);
    
    // Cloud save if VK
    if (VK_APP.user_id) {
        const key = `softtangle_data_${VK_APP.user_id}`;
        vkBridge.send('VKWebAppStorageSet', { key: key, value: json }).catch(() => {});
    }
}

async function loadGameData() {
    let loadedData = null;

    // Try VK first
    if (VK_APP.user_id) {
        try {
            const key = `softtangle_data_${VK_APP.user_id}`;
            const resp = await vkBridge.send('VKWebAppStorageGet', { keys: [key] });
            if (resp.keys[0]?.value) {
                loadedData = JSON.parse(resp.keys[0].value);
            }
        } catch (e) {}
    }

    // Fallback to local
    if (!loadedData) {
        const local = localStorage.getItem('softTangleSave_v3');
        if (local) loadedData = JSON.parse(local);
    }

    if (loadedData) {
        STATE.progress = loadedData.progress || { wins: 0 };
        STATE.settings = loadedData.settings || { sound: true, vibro: true };
        STATE.levelsSinceAd = loadedData.levelsSinceAd || 0;
    }
    
    updateToggles();
}

// --- AUDIO ---
const AudioCtx = window.AudioContext || window.webkitAudioContext;
let actx = null;

const playSound = (type) => {
    if (!STATE.settings.sound) return;
    if (!actx) actx = new AudioCtx();
    if (actx.state === 'suspended') actx.resume();

    const osc = actx.createOscillator();
    const gain = actx.createGain();
    const now = actx.currentTime;

    if (type === 'pop') {
        osc.type = 'sine';
        osc.frequency.setValueAtTime(600, now);
        osc.frequency.exponentialRampToValueAtTime(100, now + 0.15);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.15);
    } else if (type === 'win') {
        osc.type = 'triangle';
        osc.frequency.setValueAtTime(400, now);
        osc.frequency.linearRampToValueAtTime(800, now + 0.3);
        gain.gain.setValueAtTime(0.1, now);
        gain.gain.linearRampToValueAtTime(0, now + 0.6);
        setTimeout(() => playSound('pop'), 100);
    } else {
        return;
    }
    
    osc.connect(gain);
    gain.connect(actx.destination);
    osc.start(now);
    osc.stop(now + 0.6);
};

// --- CLASSES ---
class Node {
    constructor(x, y) {
        this.x = x; this.y = y;
        this.r = 18;
        this.vx = 0; this.vy = 0;
        this.isDragging = false;
    }
    
    update(w, h) {
        if (this.isDragging) return;
        this.vx *= 0.92;
        this.vy *= 0.92;
        this.x += this.vx;
        this.y += this.vy;
        const pad = 30;
        if (this.x < pad) { this.x = pad; this.vx *= -0.5; }
        if (this.x > w - pad) { this.x = w - pad; this.vx *= -0.5; }
        if (this.y < pad) { this.y = pad; this.vy *= -0.5; }
        if (this.y > h - pad) { this.y = h - pad; this.vy *= -0.5; }
    }

    draw(ctx) {
        ctx.beginPath();
        ctx.arc(this.x + 4, this.y + 4, this.r, 0, Math.PI*2);
        ctx.fillStyle = 'rgba(163, 177, 198, 0.4)';
        ctx.fill();
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.r, 0, Math.PI*2);
        const grad = ctx.createLinearGradient(this.x - 20, this.y - 20, this.x + 20, this.y + 20);
        grad.addColorStop(0, '#ffffff');
        grad.addColorStop(1, '#dfe6e9');
        ctx.fillStyle = grad;
        ctx.fill();
        if (this.isDragging) {
            ctx.lineWidth = 3;
            ctx.strokeStyle = STATE.isSolved ? CONFIG.colors.ropeFree : CONFIG.colors.ropeTangled;
            ctx.stroke();
        }
    }
}

// --- CORE LOGIC ---
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

const intersect = (p1, p2, p3, p4) => {
    const ccw = (a, b, c) => (c.y - a.y) * (b.x - a.x) > (b.y - a.y) * (c.x - a.x);
    return ccw(p1, p3, p4) !== ccw(p2, p3, p4) && ccw(p1, p2, p3) !== ccw(p1, p2, p4);
};

const resize = () => {
    const rect = canvas.getBoundingClientRect();
    const dpr = window.devicePixelRatio || 1;
    canvas.width = rect.width * dpr;
    canvas.height = rect.height * dpr;
    ctx.scale(dpr, dpr);
    canvas.logicalWidth = rect.width;
    canvas.logicalHeight = rect.height;
};
window.addEventListener('resize', resize);
setTimeout(resize, 100);

const checkSolved = () => {
    let collisions = 0;
    const edgeStatus = new Array(STATE.edges.length).fill(false);
    for (let i = 0; i < STATE.edges.length; i++) {
        for (let j = i + 1; j < STATE.edges.length; j++) {
            const [a1, a2] = STATE.edges[i];
            const [b1, b2] = STATE.edges[j];
            if (a1 === b1 || a1 === b2 || a2 === b1 || a2 === b2) continue;
            if (intersect(STATE.nodes[a1], STATE.nodes[a2], STATE.nodes[b1], STATE.nodes[b2])) {
                edgeStatus[i] = true; edgeStatus[j] = true; collisions++;
            }
        }
    }
    return { collisions, edgeStatus };
};

const generateLevel = () => {
    const mode = CONFIG.modes[STATE.modeIdx];
    const count = Math.floor(Math.random() * (mode.range[1] - mode.range[0] + 1)) + mode.range[0];
    
    let attempt = 0;
    let valid = false;
    
    while (!valid && attempt < 20) {
        attempt++;
        STATE.nodes = [];
        STATE.edges = [];
        STATE.particles = [];
        
        const cx = canvas.logicalWidth / 2;
        const cy = canvas.logicalHeight / 2;
        const rad = Math.min(cx, cy) * 0.65;

        for (let i = 0; i < count; i++) {
            const a = (i / count) * Math.PI * 2;
            STATE.nodes.push(new Node(cx + Math.cos(a)*rad, cy + Math.sin(a)*rad));
        }
        for (let i = 0; i < count; i++) {
            STATE.edges.push([i, (i+1)%count]);
        }
        if (count > 5) {
            const chordCount = Math.floor(count / 2);
            for (let k=0; k<chordCount; k++) {
                const idx1 = Math.floor(Math.random() * count);
                const idx2 = (idx1 + 2 + Math.floor(Math.random() * (count - 4))) % count;
                if (Math.abs(idx1 - idx2) > 1) STATE.edges.push([idx1, idx2]);
            }
        }
        STATE.nodes.forEach(n => {
            n.x = 50 + Math.random() * (canvas.logicalWidth - 100);
            n.y = 100 + Math.random() * (canvas.logicalHeight - 200);
        });
        const status = checkSolved();
        if (status.collisions > 0 || attempt > 15) valid = true;
    }

    STATE.startTime = Date.now();
    STATE.isSolved = false;
    STATE.levelComplete = false;
    updateHud();
};

// --- RENDER LOOP ---
const loop = () => {
    requestAnimationFrame(loop);
    if (STATE.screen !== 'game' && STATE.screen !== 'win') return;
    ctx.clearRect(0, 0, canvas.logicalWidth, canvas.logicalHeight);
    STATE.nodes.forEach(n => n.update(canvas.logicalWidth, canvas.logicalHeight));
    const { collisions, edgeStatus } = checkSolved();
    STATE.isSolved = collisions === 0;

    if (STATE.isSolved && !STATE.draggedNode && !STATE.levelComplete) {
        STATE.levelComplete = true;
        winLevel();
    }

    ctx.lineCap = 'round';
    ctx.lineJoin = 'round';
    STATE.edges.forEach((edge, i) => {
        const n1 = STATE.nodes[edge[0]];
        const n2 = STATE.nodes[edge[1]];
        const isTangled = edgeStatus[i];
        ctx.beginPath();
        ctx.moveTo(n1.x, n1.y + 4);
        ctx.lineTo(n2.x, n2.y + 4);
        ctx.lineWidth = 5;
        ctx.strokeStyle = 'rgba(163, 177, 198, 0.3)';
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(n1.x, n1.y);
        ctx.lineTo(n2.x, n2.y);
        ctx.lineWidth = 5;
        ctx.strokeStyle = isTangled ? CONFIG.colors.ropeTangled : CONFIG.colors.ropeFree;
        ctx.stroke();
        ctx.beginPath();
        ctx.moveTo(n1.x, n1.y);
        ctx.lineTo(n2.x, n2.y);
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(255,255,255,0.4)';
        ctx.stroke();
    });
    STATE.nodes.forEach(n => n.draw(ctx));
    if (STATE.particles.length > 0) {
        STATE.particles.forEach((p, i) => {
            p.x += p.vx; p.y += p.vy; p.vy += 0.1; p.life -= 0.02;
            ctx.fillStyle = p.color;
            ctx.globalAlpha = Math.max(0, p.life);
            ctx.fillRect(p.x, p.y, 5, 5);
            ctx.globalAlpha = 1;
            if(p.life <= 0) STATE.particles.splice(i, 1);
        });
    }
};

const winLevel = () => {
    const elapsed = ((Date.now() - STATE.startTime)/1000).toFixed(1);
    playSound('win');
    VK_APP.vibrate('success');
    
    STATE.progress.wins++;
    VK_APP.checkInterstitial(); // Save triggers here inside

    for(let i=0; i<60; i++) {
        STATE.particles.push({
            x: canvas.logicalWidth/2,
            y: canvas.logicalHeight/2,
            vx: (Math.random()-0.5)*15,
            vy: (Math.random()-0.5)*15,
            color: ['#ff7675', '#55efc4', '#6c5ce7', '#fdcb6e'][Math.floor(Math.random()*4)],
            life: 1.0
        });
    }

    setTimeout(() => {
        document.getElementById('winTimeDisplay').innerText = `${elapsed} сек`;
        goToScreen('winScreen');
    }, 1200);
};

// --- INPUT ---
const getPos = (e) => {
    const r = canvas.getBoundingClientRect();
    const x = (e.touches ? e.touches[0].clientX : e.clientX) - r.left;
    const y = (e.touches ? e.touches[0].clientY : e.clientY) - r.top;
    return { x: x * (canvas.logicalWidth / r.width), y: y * (canvas.logicalHeight / r.height) };
};

const onDown = (e) => {
    if (STATE.screen !== 'game') return;
    const {x, y} = getPos(e);
    for (let n of STATE.nodes) {
        if (Math.hypot(n.x - x, n.y - y) < 30) {
            STATE.draggedNode = n;
            n.isDragging = true;
            n.vx = 0; n.vy = 0;
            playSound('pop');
            VK_APP.vibrate('light');
            break;
        }
    }
};

const onMove = (e) => {
    if (!STATE.draggedNode) return;
    e.preventDefault();
    const {x, y} = getPos(e);
    STATE.draggedNode.x += (x - STATE.draggedNode.x) * 0.6;
    STATE.draggedNode.y += (y - STATE.draggedNode.y) * 0.6;
};

const onUp = () => {
    if (STATE.draggedNode) {
        STATE.draggedNode.isDragging = false;
        STATE.draggedNode = null;
    }
};

canvas.addEventListener('mousedown', onDown);
canvas.addEventListener('mousemove', onMove);
window.addEventListener('mouseup', onUp);
canvas.addEventListener('touchstart', onDown, {passive: false});
canvas.addEventListener('touchmove', onMove, {passive: false});
window.addEventListener('touchend', onUp);

// --- UI NAVIGATION ---
const goToScreen = (id) => {
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('hud').classList.add('hidden');
    document.getElementById(id).classList.remove('hidden');
    STATE.screen = id === 'pauseScreen' || id === 'winScreen' ? id : (id === 'menuScreen' ? 'menu' : 'ui');
    
    if (id === 'levelScreen') renderLevels();
    if (id === 'otherGamesScreen') renderOtherGames();
    
    // Show banner again just in case
    if (VK_APP.is_ready) vkBridge.send('VKWebAppShowBannerAd', { banner_location: 'bottom' }).catch(()=>{});
};

const startGame = (idx) => {
    STATE.modeIdx = idx;
    document.querySelectorAll('.screen').forEach(s => s.classList.add('hidden'));
    document.getElementById('hud').classList.remove('hidden');
    STATE.screen = 'game';
    resize();
    generateLevel();
};

const updateHud = () => {
    document.getElementById('hudLevelName').innerText = CONFIG.modes[STATE.modeIdx].name;
};

const renderLevels = () => {
    const list = document.getElementById('levelList');
    list.innerHTML = '';
    CONFIG.modes.forEach((m, i) => {
        const locked = STATE.progress.wins < m.unlock;
        const el = document.createElement('div');
        el.className = `level-card ${locked ? 'locked' : ''}`;
        el.innerHTML = `
            <div class="lvl-info">
                <h3>${m.name}</h3>
                <p>${m.range[0]}-${m.range[1]} Узлов</p>
            </div>
            <div class="status-badge ${!locked ? 'open' : ''}">
                ${locked ? `Треб: ${m.unlock}★` : 'ОТКРЫТО'}
            </div>
        `;
        el.onclick = () => {
            if (locked) { VK_APP.vibrate('warning'); return; }
            startGame(i);
        };
        list.appendChild(el);
    });
};

const renderOtherGames = () => {
    const list = document.getElementById('gamesList');
    list.innerHTML = '';
    CONFIG.otherGames.forEach(g => {
        const el = document.createElement('div');
        el.className = 'game-item';
        el.innerHTML = `
            <div class="game-icon"><img src="${g.icon}" alt="${g.name}"></div>
            <div class="game-name">${g.name}</div>
        `;
        el.onclick = () => VK_APP.openGame(g.appId);
        list.appendChild(el);
    });
};

// --- EVENTS ---
document.getElementById('btnPlay').onclick = () => goToScreen('levelScreen');
document.getElementById('btnOtherGamesMenu').onclick = () => goToScreen('otherGamesScreen');
document.getElementById('btnSettings').onclick = () => document.getElementById('settingsModal').classList.remove('hidden');
document.getElementById('btnCloseSettings').onclick = () => document.getElementById('settingsModal').classList.add('hidden');

document.getElementById('btnBackLevel').onclick = () => goToScreen('menuScreen');
document.getElementById('btnBackGames').onclick = () => goToScreen('menuScreen');

document.getElementById('btnPause').onclick = () => goToScreen('pauseScreen');
document.getElementById('btnResume').onclick = () => {
    document.getElementById('pauseScreen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    STATE.screen = 'game';
};

document.getElementById('btnRestart').onclick = () => generateLevel();
document.getElementById('btnExit').onclick = () => goToScreen('menuScreen');
document.getElementById('btnMenuWin').onclick = () => goToScreen('menuScreen');
document.getElementById('btnNextLevel').onclick = () => {
    document.getElementById('winScreen').classList.add('hidden');
    document.getElementById('hud').classList.remove('hidden');
    STATE.screen = 'game';
    generateLevel();
};

const updateToggles = () => {
    document.getElementById('toggleSound').className = `toggle-switch ${STATE.settings.sound ? 'active' : ''}`;
    document.getElementById('toggleVibro').className = `toggle-switch ${STATE.settings.vibro ? 'active' : ''}`;
};

document.getElementById('toggleSound').onclick = () => {
    STATE.settings.sound = !STATE.settings.sound;
    updateToggles();
    if(STATE.settings.sound && !actx) actx = new AudioCtx();
    saveGameData();
};
document.getElementById('toggleVibro').onclick = () => {
    STATE.settings.vibro = !STATE.settings.vibro;
    updateToggles();
    VK_APP.vibrate('medium');
    saveGameData();
};

// Init
resize();
VK_APP.init(); // Start VK and load data
loop();

</script>
</body>
</html>